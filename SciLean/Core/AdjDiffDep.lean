import Lean
import Init.Classical

import SciLean.Core.DifferentialDep
import SciLean.Core.Adjoint
import SciLean.Core.HasAdjDiffDep

namespace SciLean

variable {Œ± Œ≤ Œ≥ : Type}
variable {X Y Z : Type} [SemiHilbertDiff X] [SemiHilbertDiff Y] [SemiHilbertDiff Z] 
variable {Y‚ÇÅ Y‚ÇÇ : Type} [SemiHilbertDiff Y‚ÇÅ] [SemiHilbertDiff Y‚ÇÇ]
variable {Œπ : Type} [Enumtype Œπ]


noncomputable 
def adjointDifferentialDep (f : X ‚Üí Y) (x : X) (dy' : ùíØ[f x] Y) : ùíØ[x] X := (‚àÇ f x)‚Ä† dy'

instance (priority:=low) (f : X ‚Üí Y) : PartialDagger f (adjointDifferentialDep f) := ‚ü®‚ü©


-- Question: Should there be `ùíØ[y] Y` or `ùíØ[f x] Y`?
-- Maybe return `(y:Y)√ó(ùíØ[y] Y ‚Üí ùíØ[x] X)√ó(f x = y)` but there is a problem with `Sigma` vs `PSigma`
noncomputable
def reverseDifferentialDep (f : X ‚Üí Y) (x : X) : (Œ£' (y:Y) (_:ùíØ[y] Y ‚Üí ùíØ[x] X), (f x=y)) := ‚ü®f x, Œª dy => ‚àÇ‚Ä† f x dy, rfl‚ü©

instance (priority:=low) (f : X ‚Üí Y) : ReverseDifferential f (reverseDifferentialDep f) := ‚ü®‚ü©

noncomputable
abbrev gradientDep (f : X ‚Üí ‚Ñù) (x : X) : ùíØ[x] X := ‚àÇ‚Ä† f x 1

instance (priority:=low) (f : X ‚Üí ‚Ñù) : Nabla f (gradientDep f) := ‚ü®‚ü©


-- -- Notation 
-- -- ‚àá s, f s         --> ‚àá Œª s => f s
-- -- ‚àá s : ‚Ñù, f s     --> ‚àá Œª s : ‚Ñù => f s
-- -- ‚àá s := t, f s    --> (‚àá Œª s => f s) t
-- syntax "‚àá" diffBinder "," term:66 : term
-- syntax "‚àá" "(" diffBinder ")" "," term:66 : term
-- macro_rules 
-- | `(‚àá $x:ident, $f) =>
--   `(‚àá Œª $x => $f)
-- | `(‚àá $x:ident : $type:term, $f) =>
--   `(‚àá Œª $x : $type => $f)
-- | `(‚àá $x:ident := $val:term, $f) =>
--   `((‚àá Œª $x => $f) $val)
-- | `(‚àá ($b:diffBinder), $f) =>
--   `(‚àá $b, $f)


instance (f : X ‚Üí Y) [HasAdjDiffDepT f] (x : X) : IsLinT (‚àÇ‚Ä† f x) := sorry

----------------------------------------------------------------------


@[simp ‚Üì, autodiff]
theorem id.arg_x.adjDiffDep_simp
  : ‚àÇ‚Ä† (Œª x : X => x) = Œª x dx => dx := by simp[adjointDifferentialDep]; done

@[simp ‚Üì, autodiff]
theorem const.arg_x.adjDiffDep_simp 
  : ‚àÇ‚Ä† (Œª (x : X) (i : Œπ) => x) = Œª x f => ‚àë i, f i := by simp[adjointDifferentialDep]; done

@[simp ‚Üì, autodiff]
theorem const.arg_y.adjDiffDep_simp (x : X)
  : ‚àÇ‚Ä† (Œª (y : Y) => x) = (Œª y dy' => 0) := by simp[adjointDifferentialDep]; done

@[simp ‚Üì low-4, autodiff low-4]
theorem swap.arg_y.adjDiffDep_simp
  (f : Œπ ‚Üí X ‚Üí Z) [inst : ‚àÄ i, HasAdjDiffDepT (f i)]
  : ‚àÇ‚Ä† (Œª x y => f y x) = (Œª x dx' => ‚àë i, (‚àÇ‚Ä† (f i) x) (dx' i)) := 
by 
  have := Œª i => (inst i).proof.1
  have := Œª i => (inst i).proof.2

  simp[adjointDifferentialDep]; done

@[simp ‚Üì low-3, autodiff low-3]
theorem subst.arg_x.adjDiffDep_simp
  (f : X ‚Üí Y ‚Üí Z) [instf : HasAdjDiffDepNT 2 f]
  (g : X ‚Üí Y) [instg : HasAdjDiffDepT g]
  : ‚àÇ‚Ä† (Œª x => f x (g x)) 
    = 
    Œª x dx' => 
      let ‚ü®y,dg',h‚ü© := ‚Ñõ g x
      (‚àÇ‚Ä† (hold Œª x' => f x' y)) x (h ‚ñ∏ dx')
      +
      dg' (‚àÇ‚Ä† (f x) y (h ‚ñ∏ dx'))
    := 
by 
  have := instg.proof.1
  have := instg.proof.2
  have := instf.proof.1

  funext x dx';
  simp[adjointDifferentialDep, tangentMapDep]
  admit


@[simp ‚Üì low-2, autodiff low-2]
theorem subst.arg_x.parm1.adjDiffDep_simp
  (a : Œ±)
  (f : X ‚Üí Y ‚Üí Œ± ‚Üí Z) [HasAdjDiffDepNT 2 Œª x y => f x y a]
  (g : X ‚Üí Y) [instg : HasAdjDiffDepT g]
  : ‚àÇ‚Ä† (Œª x => f x (g x) a) 
    = 
    Œª x dx' => 
      let ‚ü®y,dg',h‚ü© := ‚Ñõ g x
      (‚àÇ‚Ä† (hold Œª x' => f x' y a)) x (h ‚ñ∏ dx')
      +
      dg' (‚àÇ‚Ä† (hold Œª y' => f x y' a) y (h ‚ñ∏ dx'))
    := 
by 
  apply subst.arg_x.adjDiffDep_simp (Œª x y => f x y a) g
  done

@[simp ‚Üì low-2, autodiff low-2]
theorem subst.arg_x.parm2.adjDiffDep_simp
  (a : Œ±) (b : Œ≤)
  (f : X ‚Üí Y ‚Üí Œ± ‚Üí Œ≤ ‚Üí Z) [HasAdjDiffDepNT 2 Œª x y => f x y a b]
  (g : X ‚Üí Y) [instg : HasAdjDiffDepT g]
  : ‚àÇ‚Ä† (Œª x => f x (g x) a b) 
    = 
    Œª x dx' => 
      let ‚ü®y,dg',h‚ü© := ‚Ñõ g x
      (‚àÇ‚Ä† (hold Œª x' => f x' y a b)) x (h ‚ñ∏ dx')
      +
      dg' (‚àÇ‚Ä† (hold Œª y' => f x y' a b) y (h ‚ñ∏ dx'))
    := 
by 
  apply subst.arg_x.adjDiffDep_simp (Œª x y => f x y a b) g
  done

@[simp ‚Üì low-2, autodiff low-2]
theorem subst.arg_x.parm3.adjDiffDep_simp
  (a : Œ±) (b : Œ≤) (c : Œ≥)
  (f : X ‚Üí Y ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Z) [HasAdjDiffDepNT 2 Œª x y => f x y a b c]
  (g : X ‚Üí Y) [instg : HasAdjDiffDepT g]
  : ‚àÇ‚Ä† (Œª x => f x (g x) a b c) 
    = 
    Œª x dx' => 
      let ‚ü®y,dg',h‚ü© := ‚Ñõ g x
      (‚àÇ‚Ä† (hold Œª x' => f x' y a b c)) x (h ‚ñ∏ dx')
      +
      dg' (‚àÇ‚Ä† (hold Œª y => f x y a b c) y (h ‚ñ∏ dx'))
    := 
by 
  apply subst.arg_x.adjDiffDep_simp (Œª x y => f x y a b c) g
  done

@[simp ‚Üì low-1, autodiff low-1]
theorem comp.arg_x.adjDiffDep_simp
  (f : Y ‚Üí Z) [instf : HasAdjDiffDepT f]
  (g : X ‚Üí Y) [instg : HasAdjDiffDepT g]
  : ‚àÇ‚Ä† (Œª x => f (g x)) 
    = 
    Œª x dx' => 
      let ‚ü®y,dg',h‚ü© := ‚Ñõ g x
      dg' ((‚àÇ‚Ä† f y) (h ‚ñ∏ dx')) := 
by 
  simp; unfold hold; simp
  done

@[simp ‚Üì low-2, autodiff low-2]
theorem diag.arg_x.adjDiffDep_simp
  (f : Y‚ÇÅ ‚Üí Y‚ÇÇ ‚Üí Z) [HasAdjDiffDepNT 2 f]
  (g‚ÇÅ : X ‚Üí Y‚ÇÅ) [hg : HasAdjDiffDepT g‚ÇÅ]
  (g‚ÇÇ : X ‚Üí Y‚ÇÇ) [HasAdjDiffDepT g‚ÇÇ]
  : ‚àÇ‚Ä† (Œª x => f (g‚ÇÅ x) (g‚ÇÇ x)) 
    = 
    Œª x dx' => 
      let ‚ü®y‚ÇÅ,dg‚ÇÅ',h‚ÇÅ‚ü© := ‚Ñõ g‚ÇÅ x
      let ‚ü®y‚ÇÇ,dg‚ÇÇ',h‚ÇÇ‚ü© := ‚Ñõ g‚ÇÇ x
      dg‚ÇÅ' ((‚àÇ‚Ä† Œª y‚ÇÅ => f y‚ÇÅ y‚ÇÇ) y‚ÇÅ (h‚ÇÅ ‚ñ∏ h‚ÇÇ ‚ñ∏ dx'))
      +
      dg‚ÇÇ' ((‚àÇ‚Ä† Œª y‚ÇÇ => f y‚ÇÅ y‚ÇÇ) y‚ÇÇ (h‚ÇÇ ‚ñ∏ h‚ÇÅ ‚ñ∏ dx'))
    := 
by
  simp; unfold hold; simp; unfold hold; simp[reverseDifferentialDep,adjointDifferentialDep]; done

@[simp ‚Üì low, autodiff low]
theorem eval.arg_f.adjDiffDep_simp
  (i : Œπ)
  : ‚àÇ‚Ä† (Œª (f : Œπ ‚Üí X) => f i) 
    = 
    (Œª f df' j => if h : i = j then h ‚ñ∏ df' else 0) 
  := 
by 
  simp[reverseDifferentialDep,adjointDifferentialDep]; done

@[simp ‚Üì low-1, autodiff low-1]
theorem eval.arg_x.parm1.adjDiffDep_simp
  (f : X ‚Üí Œπ ‚Üí Z) [HasAdjDiffDep f]
  : ‚àÇ‚Ä† (Œª x => f x i) 
    = 
    (Œª x dx' => (‚àÇ‚Ä† f x) (Œª j => if h : i = j then h ‚ñ∏ dx' else 0)) 
  := 
by 
  rw [comp.arg_x.adjDiffDep_simp (Œª (x : Œπ ‚Üí Z) => x i) f]
  simp[reverseDifferentialDep,adjointDifferentialDep]


--------------------------------------------------------
-- These theorems are problematic when used with simp --


@[simp ‚Üì low-1, autodiff low-1]
theorem comp.arg_x.parm1.adjDiffDep_simp
  (a : Œ±) 
  (f : Y ‚Üí Œ± ‚Üí Z) [HasAdjDiffDep Œª y => f y a]
  (g : X ‚Üí Y) [HasAdjDiffDep g]
  : 
    ‚àÇ‚Ä† (Œª x => f (g x) a)
    = 
    Œª x dx' => 
      let ‚ü®y,dg',h‚ü© := ‚Ñõ g x
      dg' ((‚àÇ‚Ä† (hold Œª y => f y a)) y (h ‚ñ∏ dx'))
:= by 
  simp; unfold hold; simp
  done

@[simp ‚Üì low-1, autodiff low-1]
theorem comp.arg_x.parm2.adjDiffDep_simp
  (a : Œ±) (b : Œ≤)
  (f : Y ‚Üí Œ± ‚Üí Œ≤ ‚Üí Z) [HasAdjDiffDep Œª y => f y a b]
  (g : X ‚Üí Y) [HasAdjDiffDep g]
  : 
    ‚àÇ‚Ä† (Œª x => f (g x) a b)
    = 
    Œª x dx' => 
      let ‚ü®y,dg',h‚ü© := ‚Ñõ g x
      dg' ((‚àÇ‚Ä† (hold Œª y => f y a b)) y (h ‚ñ∏ dx'))
:= by 
  simp; unfold hold; simp
  done

@[simp ‚Üì low-1, autodiff low-1]
theorem comp.arg_x.parm3.adjDiffDep_simp
  (a : Œ±) (b : Œ≤) (c : Œ≥)
  (f : Y ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Z) [HasAdjDiffDep Œª y => f y a b c]
  (g : X ‚Üí Y) [HasAdjDiffDep g]
  : 
    ‚àÇ‚Ä† (Œª x => f (g x) a b c)
    = 
    Œª x dx' => 
      let ‚ü®y,dg',h‚ü© := ‚Ñõ g x
      dg' ((‚àÇ‚Ä† (hold Œª y => f y a b c)) y (h ‚ñ∏ dx'))
:= by 
  simp; unfold hold; simp
  done

@[simp ‚Üì low-1, autodiff low-1] -- try to avoid using this theorem
theorem diag.arg_x.parm1.adjDiffDep_simp
  (a : Œ±)
  (f : Y‚ÇÅ ‚Üí Y‚ÇÇ ‚Üí Œ± ‚Üí Z) [HasAdjDiffDepNT 2 Œª y‚ÇÅ y‚ÇÇ => f y‚ÇÅ y‚ÇÇ a]
  (g‚ÇÅ : X ‚Üí Y‚ÇÅ) [HasAdjDiffDepT g‚ÇÅ]
  (g‚ÇÇ : X ‚Üí Y‚ÇÇ) [HasAdjDiffDepT g‚ÇÇ]
  : ‚àÇ‚Ä† (Œª x => f (g‚ÇÅ x) (g‚ÇÇ x) a)
    = 
    Œª x dx' => 
      let ‚ü®y‚ÇÅ,dg‚ÇÅ',h‚ÇÅ‚ü© := ‚Ñõ g‚ÇÅ x
      let ‚ü®y‚ÇÇ,dg‚ÇÇ',h‚ÇÇ‚ü© := ‚Ñõ g‚ÇÇ x
      dg‚ÇÅ' ((‚àÇ‚Ä† Œª y‚ÇÅ => f y‚ÇÅ y‚ÇÇ a) y‚ÇÅ (h‚ÇÅ ‚ñ∏ h‚ÇÇ ‚ñ∏ dx'))
      +
      dg‚ÇÇ' ((‚àÇ‚Ä† Œª y‚ÇÇ => f y‚ÇÅ y‚ÇÇ a) y‚ÇÇ (h‚ÇÇ ‚ñ∏ h‚ÇÅ ‚ñ∏ dx'))
:= by 
  (apply diag.arg_x.adjDiffDep_simp (Œª y‚ÇÅ y‚ÇÇ => f y‚ÇÅ y‚ÇÇ a) g‚ÇÅ g‚ÇÇ)
  
@[simp ‚Üì low-1, autodiff low-1] -- try to avoid using this theorem
theorem diag.arg_x.parm2.adjDiffDep_simp
  (a : Œ±) (b : Œ≤)
  (f : Y‚ÇÅ ‚Üí Y‚ÇÇ ‚Üí Œ± ‚Üí Œ≤ ‚Üí Z) [HasAdjDiffDepNT 2 Œª y‚ÇÅ y‚ÇÇ => f y‚ÇÅ y‚ÇÇ a b]
  (g‚ÇÅ : X ‚Üí Y‚ÇÅ) [HasAdjDiffDepT g‚ÇÅ]
  (g‚ÇÇ : X ‚Üí Y‚ÇÇ) [HasAdjDiffDepT g‚ÇÇ]
  : ‚àÇ‚Ä† (Œª x => f (g‚ÇÅ x) (g‚ÇÇ x) a b)
    = 
    Œª x dx' => 
      let ‚ü®y‚ÇÅ,dg‚ÇÅ',h‚ÇÅ‚ü© := ‚Ñõ g‚ÇÅ x
      let ‚ü®y‚ÇÇ,dg‚ÇÇ',h‚ÇÇ‚ü© := ‚Ñõ g‚ÇÇ x
      dg‚ÇÅ' ((‚àÇ‚Ä† Œª y‚ÇÅ => f y‚ÇÅ y‚ÇÇ a b) y‚ÇÅ (h‚ÇÅ ‚ñ∏ h‚ÇÇ ‚ñ∏ dx'))
      +
      dg‚ÇÇ' ((‚àÇ‚Ä† Œª y‚ÇÇ => f y‚ÇÅ y‚ÇÇ a b) y‚ÇÇ (h‚ÇÇ ‚ñ∏ h‚ÇÅ ‚ñ∏ dx'))
:= by 
  (apply diag.arg_x.adjDiffDep_simp (Œª y‚ÇÅ y‚ÇÇ => f y‚ÇÅ y‚ÇÇ a b) g‚ÇÅ g‚ÇÇ)
  done

@[simp ‚Üì low-1, autodiff low-1] -- try to avoid using this theorem
theorem diag.arg_x.parm3.adjDiffDep_simp
  (a : Œ±) (b : Œ≤) (c : Œ≥)
  (f : Y‚ÇÅ ‚Üí Y‚ÇÇ ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Z) [HasAdjDiffDepNT 2 Œª y‚ÇÅ y‚ÇÇ => f y‚ÇÅ y‚ÇÇ a b c]
  (g‚ÇÅ : X ‚Üí Y‚ÇÅ) [HasAdjDiffDepT g‚ÇÅ]
  (g‚ÇÇ : X ‚Üí Y‚ÇÇ) [HasAdjDiffDepT g‚ÇÇ]
  : ‚àÇ‚Ä† (Œª x => f (g‚ÇÅ x) (g‚ÇÇ x) a b c)
    = 
    Œª x dx' => 
      let ‚ü®y‚ÇÅ,dg‚ÇÅ',h‚ÇÅ‚ü© := ‚Ñõ g‚ÇÅ x
      let ‚ü®y‚ÇÇ,dg‚ÇÇ',h‚ÇÇ‚ü© := ‚Ñõ g‚ÇÇ x
      dg‚ÇÅ' ((‚àÇ‚Ä† Œª y‚ÇÅ => f y‚ÇÅ y‚ÇÇ a b c) y‚ÇÅ (h‚ÇÅ ‚ñ∏ h‚ÇÇ ‚ñ∏ dx'))
      +
      dg‚ÇÇ' ((‚àÇ‚Ä† Œª y‚ÇÇ => f y‚ÇÅ y‚ÇÇ a b c) y‚ÇÇ (h‚ÇÇ ‚ñ∏ h‚ÇÅ ‚ñ∏ dx'))
:= by 
  (apply diag.arg_x.adjDiffDep_simp (Œª y‚ÇÅ y‚ÇÇ => f y‚ÇÅ y‚ÇÇ a b c) g‚ÇÅ g‚ÇÇ)
  done

--------------------------------------------------------------------------------


@[simp ‚Üì, autodiff]
theorem id.arg_x.revDiffDep_simp
  : ‚Ñõ (Œª x : X => x) = Œª x => ‚ü®x, Œª x => x, rfl‚ü© := by simp[reverseDifferentialDep]; done

@[simp ‚Üì, autodiff]
theorem const.arg_x.revDiffDep_simp 
  : ‚Ñõ (Œª (x : X) (i : Œπ) => x) 
    = 
    Œª x => 
      ‚ü®(Œª i => x), (Œª f => ‚àë i, f i), rfl‚ü© 
  := by simp[reverseDifferentialDep]; done

@[simp ‚Üì, autodiff]
theorem const.arg_y.revDiffDep_simp (x : X)
  : ‚Ñõ (Œª (y : Y) => x) 
    =
    Œª y => 
      ‚ü®x, (Œª dy' => 0), rfl‚ü©
  := by simp[reverseDifferentialDep]; done

@[simp ‚Üì low-4, autodiff low-4]
theorem swap.arg_y.revDiffDep_simp
  (f : Œπ ‚Üí X ‚Üí Z) [inst : ‚àÄ i, HasAdjDiffDepT (f i)]
  : ‚àÇ‚Ä† (Œª x y => f y x) = (Œª x dx' => ‚àë i, (‚àÇ‚Ä† (f i) x) (dx' i)) := 
by 
  have := Œª i => (inst i).proof.1
  have := Œª i => (inst i).proof.2

  simp[adjointDifferentialDep]; done

@[simp ‚Üì low-3, autodiff low-3]
theorem subst.arg_x.revDiffDep_simp
  (f : X ‚Üí Y ‚Üí Z) [instf : HasAdjDiffDepNT 2 f]
  (g : X ‚Üí Y) [instg : HasAdjDiffDepT g]
  : ‚Ñõ (Œª x => f x (g x)) 
    = 
    Œª x => 
      let ‚ü®y,dg',hg‚ü© := ‚Ñõ g x
      let ‚ü®z,df',hf‚ü© := ‚Ñõ (uncurryN 2 f) (x,y)
      ‚ü®z, Œª dz' => 
           let (dx‚ÇÅ,dy) := df' dz'
           dx‚ÇÅ + dg' dy
      , by 
          rw[hg]
          rw[(rfl : uncurryN 2 f (x,y) = f x y)] at hf
          apply hf
          done‚ü©
    := 
by 
  have := instg.proof.1
  have := instg.proof.2
  have := instf.proof.1

  funext x;
  simp[adjointDifferentialDep, tangentMapDep, reverseDifferentialDep,uncurryN, Prod.Uncurry.uncurry,instUncurryHAddNatInstHAddInstAddNatOfNatForAllProd]
  admit


@[simp ‚Üì low-2, autodiff low-2]
theorem subst.arg_x.parm1.revDiffDep_simp
  (a : Œ±)
  (f : X ‚Üí Y ‚Üí Œ± ‚Üí Z) [HasAdjDiffDepNT 2 Œª x y => f x y a]
  (g : X ‚Üí Y) [instg : HasAdjDiffDepT g]
  : ‚Ñõ (Œª x => f x (g x) a) 
    = 
    Œª x => 
      let ‚ü®y,dg',hg‚ü© := ‚Ñõ g x
      let ‚ü®z,df',hf‚ü© := ‚Ñõ (uncurryN 2 (Œª x y => f x y a)) (x,y)
      ‚ü®z, Œª dz' => 
           let (dx‚ÇÅ,dy) := df' dz'
           dx‚ÇÅ + dg' dy
      , by 
          rw[hg]
          rw[(rfl : (uncurryN 2 (Œª x y => f x y a)) (x,y) = f x y a)] at hf
          apply hf
          done‚ü©
    := 
by 
  apply subst.arg_x.revDiffDep_simp (Œª x y => f x y a) g
  done

@[simp ‚Üì low-2, autodiff low-2]
theorem subst.arg_x.parm2.revDiffDep_simp
  (a : Œ±) (b : Œ≤)
  (f : X ‚Üí Y ‚Üí Œ± ‚Üí Œ≤ ‚Üí Z) [HasAdjDiffDepNT 2 Œª x y => f x y a b]
  (g : X ‚Üí Y) [instg : HasAdjDiffDepT g]
  : ‚Ñõ (Œª x => f x (g x) a b) 
    = 
    Œª x => 
      let ‚ü®y,dg',hg‚ü© := ‚Ñõ g x
      let ‚ü®z,df',hf‚ü© := ‚Ñõ (uncurryN 2 (Œª x y => f x y a b)) (x,y)
      ‚ü®z, Œª dz' => 
           let (dx‚ÇÅ,dy) := df' dz'
           dx‚ÇÅ + dg' dy
      , by 
          rw[hg]
          rw[(rfl : (uncurryN 2 (Œª x y => f x y a b)) (x,y) = f x y a b)] at hf
          apply hf
          done‚ü©
    := 
by 
  apply subst.arg_x.revDiffDep_simp (Œª x y => f x y a b) g
  done

@[simp ‚Üì low-2, autodiff low-2]
theorem subst.arg_x.parm3.revDiffDep_simp
  (a : Œ±) (b : Œ≤) (c : Œ≥)
  (f : X ‚Üí Y ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Z) [HasAdjDiffDepNT 2 Œª x y => f x y a b c]
  (g : X ‚Üí Y) [instg : HasAdjDiffDepT g]
  : ‚Ñõ (Œª x => f x (g x) a b c) 
    = 
    Œª x => 
      let ‚ü®y,dg',hg‚ü© := ‚Ñõ g x
      let ‚ü®z,df',hf‚ü© := ‚Ñõ (uncurryN 2 (Œª x y => f x y a b c)) (x,y)
      ‚ü®z, Œª dz' => let (dx‚ÇÅ,dy) := df' dz'; dx‚ÇÅ + dg' dy, 
       by rw[hg]; rw[‚Üê hf]; done‚ü©
    := 
by 
  apply subst.arg_x.revDiffDep_simp (Œª x y => f x y a b c) g
  done


-- @[simp ‚Üì low-10, autodiff low-10]
theorem uncurryN2.arg_x.diffDep_simp
  (f : X ‚Üí Y ‚Üí Z) [HasAdjDiffDepNT 2 f]
  : ‚àÇ‚Ä† (uncurryN 2 f) 
    =
    Œª (x,y) dz =>
      (‚àÇ‚Ä† (Œª x' => f x' y) x dz, ‚àÇ‚Ä† (Œª y' => f x y') y dz)
  := sorry_proof

@[simp ‚Üì low-1, autodiff low-1]
theorem comp.arg_x.revDiffDep_simp
  (f : Y ‚Üí Z) [instf : HasAdjDiffDepT f]
  (g : X ‚Üí Y) [instg : HasAdjDiffDepT g]
  : ‚Ñõ (Œª x => f (g x)) 
    = 
    Œª x => 
      let ‚ü®y,dg',hg‚ü© := ‚Ñõ g x
      let ‚ü®z,df',hf‚ü© := ‚Ñõ f y
      ‚ü®z, Œª dz => dg' (df' dz), by rw[hg]; rw[hf]; done‚ü© := 
by 
  simp[reverseDifferentialDep, uncurryN2.arg_x.diffDep_simp]
  done

@[simp ‚Üì low-2, autodiff low-2]
theorem diag.arg_x.revDiffDep_simp
  (f : Y‚ÇÅ ‚Üí Y‚ÇÇ ‚Üí Z) [HasAdjDiffDepNT 2 f]
  (g‚ÇÅ : X ‚Üí Y‚ÇÅ) [hg : HasAdjDiffDepT g‚ÇÅ]
  (g‚ÇÇ : X ‚Üí Y‚ÇÇ) [HasAdjDiffDepT g‚ÇÇ]
  : ‚Ñõ (Œª x => f (g‚ÇÅ x) (g‚ÇÇ x)) 
    = 
    Œª x => 
      let ‚ü®y‚ÇÅ,dg‚ÇÅ',h‚ÇÅ‚ü© := ‚Ñõ g‚ÇÅ x
      let ‚ü®y‚ÇÇ,dg‚ÇÇ',h‚ÇÇ‚ü© := ‚Ñõ g‚ÇÇ x
      let ‚ü®z, df', hf‚ü© := ‚Ñõ (uncurryN 2 f) (y‚ÇÅ,y‚ÇÇ)
      ‚ü®z, Œª dz => let (dy‚ÇÅ,dy‚ÇÇ) := df' dz; dg‚ÇÅ' dy‚ÇÅ + dg‚ÇÇ' dy‚ÇÇ, 
       by rw[h‚ÇÅ,h‚ÇÇ]; rw[‚Üê hf]; done‚ü©
      -- dg‚ÇÅ' ((‚àÇ‚Ä† Œª y‚ÇÅ => f y‚ÇÅ y‚ÇÇ) y‚ÇÅ (h‚ÇÅ ‚ñ∏ h‚ÇÇ ‚ñ∏ dx'))
      -- +
      -- dg‚ÇÇ' ((‚àÇ‚Ä† Œª y‚ÇÇ => f y‚ÇÅ y‚ÇÇ) y‚ÇÇ (h‚ÇÇ ‚ñ∏ h‚ÇÅ ‚ñ∏ dx'))
    := 
by
  simp[reverseDifferentialDep, uncurryN2.arg_x.diffDep_simp]; unfold hold;simp
  done

@[simp ‚Üì low, autodiff low]
theorem eval.arg_f.revDiffDep_simp
  (i : Œπ)
  : ‚Ñõ (Œª (f : Œπ ‚Üí X) => f i) 
    = 
    Œª f => 
      ‚ü®f i,
       Œª dx j => if h : i = j then h ‚ñ∏ dx else 0,
       rfl‚ü©
  := 
by 
  simp[reverseDifferentialDep,adjointDifferentialDep]; done

@[simp ‚Üì low-1, autodiff low-1]
theorem eval.arg_x.parm1.revDiffDep_simp
  (f : X ‚Üí Œπ ‚Üí Z) [HasAdjDiffDep f] (i : Œπ)
  : ‚Ñõ (Œª x => f x i) 
    = 
    Œª x =>
      let ‚ü®fx, df', hf‚ü© := ‚Ñõ f x
      ‚ü®fx i, 
      Œª dx' => df' (Œª j => if h : i = j then h ‚ñ∏ dx' else 0),
      by rw[hf]; done‚ü©
  := 
by 
  rw [comp.arg_x.revDiffDep_simp (Œª (x : Œπ ‚Üí Z) => x i) f]
  simp[reverseDifferentialDep,adjointDifferentialDep]


-- @[simp ‚Üì]
-- theorem subst.aprg_x.revDiffDep_simp'''
--   (f : X ‚Üí Y ‚Üí Z) [IsSmooth f]
--   [instfx : ‚àÄ y, HasAdjDiffDep Œª x => f x y]
--   [instfy : ‚àÄ x, HasAdjDiffDep (f x)]
--   (g : Y ‚Üí X) [instg : HasAdjDiffDep g]
--   : ‚àÇ‚Ä† (Œª y => f (g y) y) 
--     = 
--     Œª y dy' => 
--       (‚àÇ‚Ä† (Œª y' => f (g y) y')) y dy'
--       +
--       (‚àÇ‚Ä† g y) (‚àÇ‚Ä† (Œª x => f x y) (g y) dy')
--     := 
-- by 
--   sorry




