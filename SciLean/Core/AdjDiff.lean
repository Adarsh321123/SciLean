import Lean
import Init.Classical

import SciLean.Core.Differential
import SciLean.Core.Adjoint
import SciLean.Core.HasAdjDiff

namespace SciLean

variable {Œ± Œ≤ Œ≥ : Type}
variable {X Y Z : Type} [SemiHilbert X] [SemiHilbert Y] [SemiHilbert Z] 
variable {Y‚ÇÅ Y‚ÇÇ : Type} [SemiHilbert Y‚ÇÅ] [SemiHilbert Y‚ÇÇ]
variable {Œπ : Type} [Enumtype Œπ]


-- noncomputable 
-- def adjointDifferential (f : X ‚Üí Y) (x : X) (dy' : Y) : X := (‚àÇ f x)‚Ä† dy'

-- @[default_instance]
-- instance (f : X ‚Üí Y) : PartialDagger f (adjointDifferential f) := ‚ü®‚ü©

-- Someting wrong here :(
-- noncomputable 
-- def Smooth.adjointDifferential {X Y} [Hilbert X] [Hilbert Y] (f : X ‚üø Y) : X‚üøY‚ä∏X := Œª x ‚üø Œª dy ‚ä∏ adjoint (‚àÇ f x) dy

-- @[default_instance]
-- instance (f : X ‚Üí Y) : PartialDagger f (adjointDifferential f) := ‚ü®‚ü©


-- Question: Should there be `ùíØ[y] Y` or `ùíØ[f x] Y`?
-- Maybe return `(y:Y)√ó(ùíØ[y] Y ‚Üí ùíØ[x] X)√ó(f x = y)` but there is a problem with `Sigma` vs `PSigma`
-- noncomputable
-- def reverseDifferential (f : X ‚Üí Y) (x : X) : Y√ó(Y‚ÜíX) := (f x, Œª dy => ‚àÇ‚Ä† f x dy)

-- instance (priority:=low) (f : X ‚Üí Y) : ReverseDifferential f (reverseDifferential f) := ‚ü®‚ü©


-- noncomputable
-- abbrev gradient (f : X ‚Üí ‚Ñù) (x : X) : X := ‚àÇ‚Ä† f x 1

-- @[default_instance]
-- instance (f : X ‚Üí ‚Ñù) : Nabla f (gradient f) := ‚ü®‚ü©

-- noncomputable
-- abbrev Smooth.gradient (f : X ‚üø ‚Ñù) : X‚üøX := SmoothMap.mk (Œª x => adjoint (Œª dx => ‚àÇ f x dx) 1) sorry_proof

-- instance (f : X ‚üø ‚Ñù) : Nabla f (Smooth.gradient f) := ‚ü®‚ü©


-- Notation 
-- ‚àá s, f s         --> ‚àá Œª s => f s
-- ‚àá s : ‚Ñù, f s     --> ‚àá Œª s : ‚Ñù => f s
-- ‚àá s := t, f s    --> (‚àá Œª s => f s) t
syntax "‚àá" diffBinder "," term:66 : term
syntax "‚àá" "(" diffBinder ")" "," term:66 : term
macro_rules 
| `(‚àá $x:ident, $f) =>
  `(‚àá Œª $x => $f)
| `(‚àá $x:ident : $type:term, $f) =>
  `(‚àá Œª $x : $type => $f)
| `(‚àá $x:ident := $val:term, $f) =>
  `((‚àá Œª $x => $f) $val)
| `(‚àá ($b:diffBinder), $f) =>
  `(‚àá $b, $f)


instance (f : X ‚Üí Y) [HasAdjDiff f] (x : X) : IsLin (‚àÇ‚Ä† f x) := sorry

----------------------------------------------------------------------


@[simp ‚Üì, autodiff]
theorem id.arg_x.adjDiff_simp
  : ‚àÇ‚Ä† (Œª x : X => x) = Œª x dx => dx := by simp[adjointDifferential]; done

@[simp ‚Üì, autodiff]
theorem const.arg_x.adjDiff_simp 
  : ‚àÇ‚Ä† (Œª (x : X) (i : Œπ) => x) = Œª x f => ‚àë i, f i := by simp[adjointDifferential]; done

@[simp ‚Üì, autodiff]
theorem const.arg_y.adjDiff_simp (x : X)
  : ‚àÇ‚Ä† (Œª (y : Y) => x) = (Œª y dy' => (0 : Y)) := by simp[adjointDifferential]; done

@[simp ‚Üì low-4, autodiff low-4]
theorem swap.arg_y.adjDiff_simp
  (f : Œπ ‚Üí X ‚Üí Z) [inst : ‚àÄ i, HasAdjDiffT (f i)]
  : ‚àÇ‚Ä† (Œª x y => f y x) = (Œª x dx' => ‚àë i, (‚àÇ‚Ä† (f i) x) (dx' i)) := 
by 
  have := Œª i => (inst i).proof.1
  have := Œª i => (inst i).proof.2

  simp[adjointDifferential]; done

@[simp ‚Üì low-3, autodiff low-3]
theorem subst.arg_x.adjDiff_simp
  (f : X ‚Üí Y ‚Üí Z) [instf : HasAdjDiffNT 2 f]
  (g : X ‚Üí Y) [instg : HasAdjDiffT g]
  : ‚àÇ‚Ä† (Œª x => f x (g x)) 
    = 
    Œª x dz =>
      let (y,dg') := ‚Ñõ g x
      -- let (dx,dy) := ‚àÇ‚Ä† (uncurryN 2 f) (x,y) dz
      -- dx + dg' dy
      (‚àÇ‚Ä† (Œª x' => f x' y)) x dz
      +
      dg' (‚àÇ‚Ä† (f x) y dz)
    := 
by 
  have := instg.proof.1
  have := instg.proof.2
  have := instf.proof.1
  -- these follow from instf.proof.2
  have : ‚àÄ x y, HasAdjointT (Œª dx => ‚àÇ f x dx y) := sorry_proof
  have : ‚àÄ x y, HasAdjointT (Œª dy => ‚àÇ (f x) y dy) := sorry_proof

  simp[adjointDifferential, reverseDifferential, tangentMap, -comp.arg_x.parm1.adj_simp]
  done

@[simp ‚Üì low-2, autodiff low-2, simp_guard g (Œª x => x)]
theorem subst.arg_x.parm1.adjDiff_simp
  (a : Œ±)
  (f : X ‚Üí Y ‚Üí Œ± ‚Üí Z) [HasAdjDiffNT 2 Œª x y => f x y a]
  (g : X ‚Üí Y) [instg : HasAdjDiffT g]
  : ‚àÇ‚Ä† (Œª x => f x (g x) a) 
    = 
    Œª x dz => 
      let (y,dg') := ‚Ñõ g x
      -- let (dx,dy) := ‚àÇ‚Ä† (uncurryN 2 (Œª x y => f x y a)) (x,y) dz
      -- dx + dg' dy
      (‚àÇ‚Ä† (Œª x' => f x' y a)) x dz
      +
      dg' (‚àÇ‚Ä† (Œª y' => f x y' a) y dz)
    := 
by 
  rw[subst.arg_x.adjDiff_simp (Œª x y => f x y a) g]
  done

@[simp ‚Üì low-2, autodiff low-2, simp_guard g (Œª x => x)]
theorem subst.arg_x.parm2.adjDiff_simp
  (a : Œ±) (b : Œ≤)
  (f : X ‚Üí Y ‚Üí Œ± ‚Üí Œ≤ ‚Üí Z) [HasAdjDiffNT 2 Œª x y => f x y a b]
  (g : X ‚Üí Y) [instg : HasAdjDiffT g]
  : ‚àÇ‚Ä† (Œª x => f x (g x) a b) 
    = 
    Œª x dz => 
      let (y,dg') := ‚Ñõ g x
      (‚àÇ‚Ä† (Œª x' => f x' y a b)) x dz
      +
      dg' (‚àÇ‚Ä† (Œª y' => f x y' a b) y dz)
    := 
by 
  apply subst.arg_x.adjDiff_simp (Œª x y => f x y a b) g
  done

@[simp ‚Üì low-2, autodiff low-2, simp_guard g (Œª x => x)]
theorem subst.arg_x.parm3.adjDiff_simp
  (a : Œ±) (b : Œ≤) (c : Œ≥)
  (f : X ‚Üí Y ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Z) [HasAdjDiffNT 2 Œª x y => f x y a b c]
  (g : X ‚Üí Y) [instg : HasAdjDiffT g]
  : ‚àÇ‚Ä† (Œª x => f x (g x) a b c) 
    = 
    Œª x dz => 
      let (y,dg') := ‚Ñõ g x
      (‚àÇ‚Ä† (Œª x' => f x' y a b c)) x dz
      +
      dg' (‚àÇ‚Ä† (Œª y' => f x y' a b c) y dz)
    := 
by 
  apply subst.arg_x.adjDiff_simp (Œª x y => f x y a b c) g
  done

@[simp ‚Üì low-1, autodiff low-1, simp_guard g (Œª x => x)]
theorem comp.arg_x.adjDiff_simp
  (f : Y ‚Üí Z) [instf : HasAdjDiffT f]
  (g : X ‚Üí Y) [instg : HasAdjDiffT g]
  : ‚àÇ‚Ä† (Œª x => f (g x)) 
    = 
    Œª x dz => 
      let (y,dg') := ‚Ñõ g x
      dg' ((‚àÇ‚Ä† f y) dz) 
  := by simp; done

@[simp ‚Üì low-2, autodiff low-2, simp_guard g‚ÇÅ Prod.fst, g‚ÇÇ Prod.snd]
theorem diag.arg_x.adjDiff_simp
  (f : Y‚ÇÅ ‚Üí Y‚ÇÇ ‚Üí Z) [HasAdjDiffNT 2 f]
  (g‚ÇÅ : X ‚Üí Y‚ÇÅ) [hg : HasAdjDiffT g‚ÇÅ]
  (g‚ÇÇ : X ‚Üí Y‚ÇÇ) [HasAdjDiffT g‚ÇÇ]
  : ‚àÇ‚Ä† (Œª x => f (g‚ÇÅ x) (g‚ÇÇ x)) 
    = 
    Œª x dz => 
      let (y‚ÇÅ,dg‚ÇÅ') := ‚Ñõ g‚ÇÅ x
      let (y‚ÇÇ,dg‚ÇÇ') := ‚Ñõ g‚ÇÇ x
      dg‚ÇÅ' ((‚àÇ‚Ä† Œª y‚ÇÅ' => f y‚ÇÅ' y‚ÇÇ) y‚ÇÅ dz)
      +
      dg‚ÇÇ' ((‚àÇ‚Ä† Œª y‚ÇÇ' => f y‚ÇÅ y‚ÇÇ') y‚ÇÇ dz)
    := 
by
  rw[subst.arg_x.adjDiff_simp]
  simp only [hold,reverseDifferential]
  funext x dz
  rw[comp.arg_x.adjDiff_simp (Œª y‚ÇÅ => f y‚ÇÅ (g‚ÇÇ x))]
  simp only [reverseDifferential]
  done

@[simp ‚Üì low, autodiff low]
theorem eval.arg_f.adjDiff_simp
  (i : Œπ)
  : ‚àÇ‚Ä† (Œª (f : Œπ ‚Üí X) => f i) 
    = 
    (Œª f df' j => ([[i = j]] * df' : X))
:= sorry

@[simp ‚Üì low-1, autodiff low-1]
theorem eval.arg_x.parm1.adjDiff_simp
  (f : X ‚Üí Œπ ‚Üí Z) [HasAdjDiff f]
  : ‚àÇ‚Ä† (Œª x => f x i) 
    = 
    (Œª x dx' => (‚àÇ‚Ä† f x) (Œª j => ([[i = j]] * dx' : Z)))
:= 
by 
  rw [comp.arg_x.adjDiff_simp (Œª (x : Œπ ‚Üí Z) => x i) f]
  simp[reverseDifferential]


--------------------------------------------------------
-- These theorems are problematic when used with simp --


@[simp ‚Üì low-1, autodiff low-1]
theorem comp.arg_x.parm1.adjDiff_simp
  (a : Œ±) 
  (f : Y ‚Üí Œ± ‚Üí Z) [HasAdjDiff Œª y => f y a]
  (g : X ‚Üí Y) [HasAdjDiff g]
  : 
    ‚àÇ‚Ä† (Œª x => f (g x) a) 
    = 
    Œª x dz => 
      let (y,dg') := ‚Ñõ g x
      dg' ((‚àÇ‚Ä† (hold Œª y => f y a)) y dz)
:= by 
  rw[subst.arg_x.parm1.adjDiff_simp]
  simp[-subst.arg_x.parm1.adjDiff_simp,hold]
  done

@[simp ‚Üì low-1, autodiff low-1]
theorem comp.arg_x.parm2.adjDiff_simp
  (a : Œ±) (b : Œ≤)
  (f : Y ‚Üí Œ± ‚Üí Œ≤ ‚Üí Z) [HasAdjDiff Œª y => f y a b]
  (g : X ‚Üí Y) [HasAdjDiff g]
  : 
    ‚àÇ‚Ä† (Œª x => f (g x) a b) 
    = 
    Œª x dz => 
      let (y,dg') := ‚Ñõ g x
      dg' ((‚àÇ‚Ä† (hold Œª y => f y a b)) y dz)
:= by 
  rw[subst.arg_x.parm2.adjDiff_simp]
  simp[-subst.arg_x.parm2.adjDiff_simp,hold]
  done

@[simp ‚Üì low-1, autodiff low-1]
theorem comp.arg_x.parm3.adjDiff_simp
  (a : Œ±) (b : Œ≤) (c : Œ≥)
  (f : Y ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Z) [HasAdjDiff Œª y => f y a b c]
  (g : X ‚Üí Y) [HasAdjDiff g]
  : 
    ‚àÇ‚Ä† (Œª x => f (g x) a b c) 
    = 
    Œª x dx' => 
      let (y,dg') := ‚Ñõ g x
      dg' ((‚àÇ‚Ä† (hold Œª y => f y a b c)) y dx')
:= by 
  rw[subst.arg_x.parm3.adjDiff_simp]
  simp[-subst.arg_x.parm3.adjDiff_simp,hold]
  done


-- TODO: fix this!!!
example (a : Œ±) (f : Y‚ÇÅ ‚Üí Y‚ÇÇ ‚Üí Œ± ‚Üí Z) [IsSmoothT Œª y‚ÇÅ y‚ÇÇ => f y‚ÇÅ y‚ÇÇ a]
  (g‚ÇÅ : X ‚Üí Y‚ÇÅ) [hg : IsSmoothT g‚ÇÅ] : IsSmoothT (Œª x y => f (g‚ÇÅ x) y a) := by (try infer_instance); admit


@[simp ‚Üì low-1, autodiff low-1] -- try to avoid using this theorem
theorem diag.arg_x.parm1.adjDiff_simp
  (a : Œ±)
  (f : Y‚ÇÅ ‚Üí Y‚ÇÇ ‚Üí Œ± ‚Üí Z) [HasAdjDiffNT 2 Œª y‚ÇÅ y‚ÇÇ => f y‚ÇÅ y‚ÇÇ a]
  (g‚ÇÅ : X ‚Üí Y‚ÇÅ) [HasAdjDiffT g‚ÇÅ]
  (g‚ÇÇ : X ‚Üí Y‚ÇÇ) [HasAdjDiffT g‚ÇÇ]
  : ‚àÇ‚Ä† (Œª x => f (g‚ÇÅ x) (g‚ÇÇ x) a)
    = 
    Œª x dz => 
      let (y‚ÇÅ,dg‚ÇÅ') := ‚Ñõ g‚ÇÅ x
      let (y‚ÇÇ,dg‚ÇÇ') := ‚Ñõ g‚ÇÇ x
      dg‚ÇÅ' ((‚àÇ‚Ä† (hold Œª y‚ÇÅ' => f y‚ÇÅ' y‚ÇÇ a)) y‚ÇÅ dz)
      +
      dg‚ÇÇ' ((‚àÇ‚Ä† (hold Œª y‚ÇÇ' => f y‚ÇÅ y‚ÇÇ' a)) y‚ÇÇ dz)
:= by 
  (apply diag.arg_x.adjDiff_simp (Œª y‚ÇÅ y‚ÇÇ => f y‚ÇÅ y‚ÇÇ a) g‚ÇÅ g‚ÇÇ)
  
@[simp ‚Üì low-1, autodiff low-1] -- try to avoid using this theorem
theorem diag.arg_x.parm2.adjDiff_simp
  (a : Œ±) (b : Œ≤)
  (f : Y‚ÇÅ ‚Üí Y‚ÇÇ ‚Üí Œ± ‚Üí Œ≤ ‚Üí Z) [HasAdjDiffNT 2 Œª y‚ÇÅ y‚ÇÇ => f y‚ÇÅ y‚ÇÇ a b]
  (g‚ÇÅ : X ‚Üí Y‚ÇÅ) [HasAdjDiffT g‚ÇÅ]
  (g‚ÇÇ : X ‚Üí Y‚ÇÇ) [HasAdjDiffT g‚ÇÇ]
  : ‚àÇ‚Ä† (Œª x => f (g‚ÇÅ x) (g‚ÇÇ x) a b)
    = 
    Œª x dz => 
      let (y‚ÇÅ,dg‚ÇÅ') := ‚Ñõ g‚ÇÅ x
      let (y‚ÇÇ,dg‚ÇÇ') := ‚Ñõ g‚ÇÇ x
      dg‚ÇÅ' ((‚àÇ‚Ä† (hold Œª y‚ÇÅ' => f y‚ÇÅ' y‚ÇÇ a b)) y‚ÇÅ dz)
      +
      dg‚ÇÇ' ((‚àÇ‚Ä† (hold Œª y‚ÇÇ' => f y‚ÇÅ y‚ÇÇ' a b)) y‚ÇÇ dz)
:= by 
  (apply diag.arg_x.adjDiff_simp (Œª y‚ÇÅ y‚ÇÇ => f y‚ÇÅ y‚ÇÇ a b) g‚ÇÅ g‚ÇÇ)
  done

@[simp ‚Üì low-1, autodiff low-1] -- try to avoid using this theorem
theorem diag.arg_x.parm3.adjDiff_simp
  (a : Œ±) (b : Œ≤) (c : Œ≥)
  (f : Y‚ÇÅ ‚Üí Y‚ÇÇ ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Z) [HasAdjDiffNT 2 Œª y‚ÇÅ y‚ÇÇ => f y‚ÇÅ y‚ÇÇ a b c]
  (g‚ÇÅ : X ‚Üí Y‚ÇÅ) [HasAdjDiffT g‚ÇÅ]
  (g‚ÇÇ : X ‚Üí Y‚ÇÇ) [HasAdjDiffT g‚ÇÇ]
  : ‚àÇ‚Ä† (Œª x => f (g‚ÇÅ x) (g‚ÇÇ x) a b c)
    = 
    Œª x dz => 
      let (y‚ÇÅ,dg‚ÇÅ') := ‚Ñõ g‚ÇÅ x
      let (y‚ÇÇ,dg‚ÇÇ') := ‚Ñõ g‚ÇÇ x
      dg‚ÇÅ' ((‚àÇ‚Ä† (hold Œª y‚ÇÅ' => f y‚ÇÅ' y‚ÇÇ a b c)) y‚ÇÅ dz)
      +
      dg‚ÇÇ' ((‚àÇ‚Ä† (hold Œª y‚ÇÇ' => f y‚ÇÅ y‚ÇÇ' a b c)) y‚ÇÇ dz)
:= by 
  (apply diag.arg_x.adjDiff_simp (Œª y‚ÇÅ y‚ÇÇ => f y‚ÇÅ y‚ÇÇ a b c) g‚ÇÅ g‚ÇÇ)
  done

----------------------------------------------------------------------


@[simp ‚Üì, autodiff]
theorem Prod.fst.arg_xy.adjDiff_simp
  : ‚àÇ‚Ä† (Prod.fst : X√óY ‚Üí X)
    =
    Œª xy dx => (dx,0)
  := by unfold adjointDifferential; simp; done

@[simp ‚Üì, autodiff]
theorem Prod.snd.arg_xy.adjDiff_simp
  : ‚àÇ‚Ä† (Prod.snd : X√óY ‚Üí Y)
    =
    Œª xy dy => (0,dy)
  := by unfold adjointDifferential; simp; done

@[simp ‚Üì, autodiff]
theorem HAdd.hAdd.arg_xy.adjDiff_simp
  : ‚àÇ‚Ä† (uncurryN 2 Œª x y : X => x + y)
    =
    Œª xy dx => (dx,dx)
  :=  by unfold adjointDifferential; simp; done

@[simp ‚Üì, autodiff]
theorem Prod.fst.arg_xy.revDiff_simp
  : ‚Ñõ (Prod.fst : X√óY ‚Üí X)
    =
    Œª (x,y) => (x, Œª dx => (dx,0))
  := by unfold reverseDifferential; simp; done

@[simp ‚Üì, autodiff]
theorem Prod.snd.arg_xy.revDiff_simp
  : ‚Ñõ (Prod.snd : X√óY ‚Üí Y)
    =
    Œª (x,y) => (y, Œª dy => (0,dy))
  := by unfold reverseDifferential; simp; done

@[simp ‚Üì, autodiff]
theorem HAdd.hAdd.arg_xy.revDiff_simp
  : ‚Ñõ (uncurryN 2 Œª x y : X => x + y)
    =
    Œª (x,y) => (x+y, Œª dx => (dx,dx))
  := by unfold reverseDifferential; simp; done


--------------------------------------------------------------------------------


@[simp ‚Üì, autodiff]
theorem id.arg_x.revDiff_simp
  : ‚Ñõ (Œª x : X => x) = Œª x => (x, Œª x => x) := by simp[reverseDifferential]; done

@[simp ‚Üì, autodiff]
theorem const.arg_x.revDiff_simp 
  : ‚Ñõ (Œª (x : X) (i : Œπ) => x) 
    = 
    Œª x => ((Œª i => x), (Œª f => ‚àë i, f i))
  := by simp[reverseDifferential]; done

@[simp ‚Üì, autodiff]
theorem const.arg_y.revDiff_simp (x : X)
  : ‚Ñõ (Œª (y : Y) => x) 
    =
    Œª y => 
      (x, (Œª dy' => 0))
  := by simp[reverseDifferential]; done

@[simp ‚Üì low-4, autodiff low-4]
theorem swap.arg_y.revDiff_simp
  (f : Œπ ‚Üí X ‚Üí Z) [inst : ‚àÄ i, HasAdjDiffT (f i)]
  : ‚àÇ‚Ä† (Œª x y => f y x) = (Œª x dx' => ‚àë i, (‚àÇ‚Ä† (f i) x) (dx' i)) := 
by 
  have := Œª i => (inst i).proof.1
  have := Œª i => (inst i).proof.2

  simp[adjointDifferential]; done

@[simp ‚Üì low-3, autodiff low-3, simp_guard g (Œª x => x)]
theorem subst.arg_x.revDiff_simp
  (f : X ‚Üí Y ‚Üí Z) [instf : HasAdjDiffNT 2 f]
  (g : X ‚Üí Y) [instg : HasAdjDiffT g]
  : ‚Ñõ (Œª x => f x (g x)) 
    = 
    Œª x => 
      let (y,dg') := ‚Ñõ g x
      let (z,df') := ‚Ñõ (uncurryN 2 f) (x,y)
      (z, Œª dz' => 
           let (dx‚ÇÅ,dy) := df' dz'
           dx‚ÇÅ + dg' dy)
      
    := 
by 
  have := instg.proof.1
  have := instg.proof.2
  have := instf.proof.1

  funext x;
  unfold reverseDifferential
  rw[subst.arg_x.adjDiff_simp]

  simp only [uncurryN, Prod.Uncurry.uncurry]
  simp only [hold, reverseDifferential]
  conv => (rhs; rw[diag.arg_x.adjDiff_simp])
  simp only [reverseDifferential, 
             Prod.fst.arg_xy.adjDiff_simp, 
             Prod.snd.arg_xy.adjDiff_simp,
             prod_add_elemwise, 
             add_zero, zero_add]
  done


@[simp ‚Üì low-2, autodiff low-2, simp_guard g (Œª x => x)]
theorem subst.arg_x.parm1.revDiff_simp
  (a : Œ±)
  (f : X ‚Üí Y ‚Üí Œ± ‚Üí Z) [HasAdjDiffNT 2 Œª x y => f x y a]
  (g : X ‚Üí Y) [instg : HasAdjDiffT g]
  : ‚Ñõ (Œª x => f x (g x) a) 
    = 
    Œª x => 
      let (y,dg') := ‚Ñõ g x
      let (z,df') := ‚Ñõ (uncurryN 2 (Œª x y => f x y a)) (x,y)
      (z, Œª dz' => 
           let (dx‚ÇÅ,dy) := df' dz'
           dx‚ÇÅ + dg' dy)
    := 
by 
  apply subst.arg_x.revDiff_simp (Œª x y => f x y a) g
  done

@[simp ‚Üì low-2, autodiff low-2, simp_guard g (Œª x => x)]
theorem subst.arg_x.parm2.revDiff_simp
  (a : Œ±) (b : Œ≤)
  (f : X ‚Üí Y ‚Üí Œ± ‚Üí Œ≤ ‚Üí Z) [HasAdjDiffNT 2 Œª x y => f x y a b]
  (g : X ‚Üí Y) [instg : HasAdjDiffT g]
  : ‚Ñõ (Œª x => f x (g x) a b) 
    = 
    Œª x => 
      let (y,dg') := ‚Ñõ g x
      let (z,df') := ‚Ñõ (uncurryN 2 (Œª x y => f x y a b)) (x,y)
      (z, Œª dz' => 
           let (dx‚ÇÅ,dy) := df' dz'
           dx‚ÇÅ + dg' dy)
    := 
by 
  apply subst.arg_x.revDiff_simp (Œª x y => f x y a b) g
  done

@[simp ‚Üì low-2, autodiff low-2, simp_guard g (Œª x => x)]
theorem subst.arg_x.parm3.revDiff_simp
  (a : Œ±) (b : Œ≤) (c : Œ≥)
  (f : X ‚Üí Y ‚Üí Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Z) [HasAdjDiffNT 2 Œª x y => f x y a b c]
  (g : X ‚Üí Y) [instg : HasAdjDiffT g]
  : ‚Ñõ (Œª x => f x (g x) a b c) 
    = 
    Œª x => 
      let (y,dg') := ‚Ñõ g x
      let (z,df') := ‚Ñõ (uncurryN 2 (Œª x y => f x y a b c)) (x,y)
      (z, Œª dz' => let (dx‚ÇÅ,dy) := df' dz'; dx‚ÇÅ + dg' dy)
    := 
by 
  apply subst.arg_x.revDiff_simp (Œª x y => f x y a b c) g
  done


-- @[simp ‚Üì low-10, autodiff low-10]
theorem uncurryN2.arg_x.diff_simp
  (f : X ‚Üí Y ‚Üí Z) [HasAdjDiffNT 2 f]
  : ‚àÇ‚Ä† (uncurryN 2 f) 
    =
    Œª (x,y) dz =>
      (‚àÇ‚Ä† (Œª x' => f x' y) x dz, ‚àÇ‚Ä† (Œª y' => f x y') y dz)
  := sorry_proof

@[simp ‚Üì low-1, autodiff low-1]
theorem comp.arg_x.revDiff_simp
  (f : Y ‚Üí Z) [instf : HasAdjDiffT f]
  (g : X ‚Üí Y) [instg : HasAdjDiffT g]
  : ‚Ñõ (Œª x => f (g x)) 
    = 
    Œª x => 
      let (y,dg') := ‚Ñõ g x
      let (z,df') := ‚Ñõ f y
      (z, Œª dz => dg' (df' dz)) := 
by 
  unfold reverseDifferential
  simp only [comp.arg_x.adjDiff_simp]
  simp only [reverseDifferential]
  done

@[simp ‚Üì low-2, autodiff low-2]
theorem diag.arg_x.revDiff_simp
  (f : Y‚ÇÅ ‚Üí Y‚ÇÇ ‚Üí Z) [HasAdjDiffNT 2 f]
  (g‚ÇÅ : X ‚Üí Y‚ÇÅ) [hg : HasAdjDiffT g‚ÇÅ]
  (g‚ÇÇ : X ‚Üí Y‚ÇÇ) [HasAdjDiffT g‚ÇÇ]
  : ‚Ñõ (Œª x => f (g‚ÇÅ x) (g‚ÇÇ x)) 
    = 
    Œª x => 
      let (y‚ÇÅ,dg‚ÇÅ') := ‚Ñõ g‚ÇÅ x
      let (y‚ÇÇ,dg‚ÇÇ') := ‚Ñõ g‚ÇÇ x
      let (z, df') := ‚Ñõ (uncurryN 2 f) (y‚ÇÅ,y‚ÇÇ)
      (z, Œª dz => let (dy‚ÇÅ,dy‚ÇÇ) := df' dz; dg‚ÇÅ' dy‚ÇÅ + dg‚ÇÇ' dy‚ÇÇ)
      -- dg‚ÇÅ' ((‚àÇ‚Ä† Œª y‚ÇÅ => f y‚ÇÅ y‚ÇÇ) y‚ÇÅ (h‚ÇÅ ‚ñ∏ h‚ÇÇ ‚ñ∏ dx'))
      -- +
      -- dg‚ÇÇ' ((‚àÇ‚Ä† Œª y‚ÇÇ => f y‚ÇÅ y‚ÇÇ) y‚ÇÇ (h‚ÇÇ ‚ñ∏ h‚ÇÅ ‚ñ∏ dx'))
    := 
by
  unfold reverseDifferential
  funext x
  simp only [uncurryN, Prod.Uncurry.uncurry]
  conv => lhs; enter [2,dz]; rw [diag.arg_x.adjDiff_simp]
  conv => rhs; enter [2,dz]; rw [diag.arg_x.adjDiff_simp]
  simp only [reverseDifferential,             
             Prod.fst.arg_xy.adjDiff_simp, 
             Prod.snd.arg_xy.adjDiff_simp, 
             prod_add_elemwise, 
             add_zero, zero_add]
  done

@[simp ‚Üì low, autodiff low]
theorem eval.arg_f.revDiff_simp
  (i : Œπ)
  : ‚Ñõ (Œª (f : Œπ ‚Üí X) => f i) 
    = 
    Œª f => (f i, (Œª dx j => ([[i=j]] * dx : X)))
  := 
by 
  simp[reverseDifferential,adjointDifferential]; done

@[simp ‚Üì low-1, autodiff low-1]
theorem eval.arg_x.parm1.revDiff_simp
  (f : X ‚Üí Œπ ‚Üí Z) [HasAdjDiff f] (i : Œπ)
  : ‚Ñõ (Œª x => f x i)
    = 
    Œª x =>
      let (fx, df') := ‚Ñõ f x
      (fx i, 
      Œª dz => df' (Œª j => ([[i=j]] * dz)))
  := 
by 
  rw [comp.arg_x.revDiff_simp (Œª (x : Œπ ‚Üí Z) => x i) f]
  simp[reverseDifferential,adjointDifferential]


-- @[simp ‚Üì]
-- theorem subst.arg_x.revDiff_simp'''
--   (f : X ‚Üí Y ‚Üí Z) [IsSmooth f]
--   [instfx : ‚àÄ y, HasAdjDiff Œª x => f x y]
--   [instfy : ‚àÄ x, HasAdjDiff (f x)]
--   (g : Y ‚Üí X) [instg : HasAdjDiff g]
--   : ‚àÇ‚Ä† (Œª y => f (g y) y) 
--     = 
--     Œª y dy' => 
--       (‚àÇ‚Ä† (Œª y' => f (g y) y')) y dy'
--       +
--       (‚àÇ‚Ä† g y) (‚àÇ‚Ä† (Œª x => f x y) (g y) dy')
--     := 
-- by 
--   sorry








