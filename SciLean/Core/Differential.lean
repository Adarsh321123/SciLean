import Lean
import Init.Classical

import SciLean.Core.Attributes
import SciLean.Core.IsSmooth
import SciLean.Core.IsLin

namespace SciLean

variable {Œ± Œ≤ Œ≥ : Type}
variable {X Y Z : Type} [Vec X] [Vec Y] [Vec Z] 
variable {Y‚ÇÅ Y‚ÇÇ : Type} [Vec Y‚ÇÅ] [Vec Y‚ÇÇ]

--------------------------------------------------------------------------------
-- Differential --
--------------------------------------------------------------------------------

noncomputable 
opaque differential (f : X ‚Üí Y) (x dx : X) : Y := 
    match Classical.propDecidable (IsSmooth f) with
      | isTrue  h => Mathlib.Convenient.derivative f h.proof x dx
      /- For nondifferentiable function the value is not specified.
         Maybe we could assign zero, similarly to division by zero.
         With zero, `differential` might be semilinear in `f`.
         This should be investigated! -/
      | _ => 0

@[default_instance]
instance (f : X ‚Üí Y) : Partial f (differential f) := ‚ü®‚ü©

-- maybe provide notation  `‚àÇ[dx] (x:=x‚ÇÄ), f x = ‚àÇ f x‚ÇÄ dx` and its variants
-- Variants
--     1. ‚àÇ[dx] (x:=x‚ÇÄ), f x          -- `‚àÇ[dx]` would be directional derivative operator
--     2. ‚àÇ (x:=x‚ÇÄ,dx), f x           -- this has weird version without `x‚ÇÄ` ‚àÇ (x:=;dx), f x 
--     3. ‚àÇ_dx (x:=x‚ÇÄ), f x           -- Can we parse this properly? What if `dx` is complicated, do we allow `‚àÇ_(dx)` ?
--     4. ??
-- macro "‚àÇ" x:Lean.Parser.Term.funBinder "," f:term:66 : term => `(‚àÇ Œª $x => $f)
syntax diffBinderType  := ":" term
syntax diffBinderValue := ":=" term
syntax diffBinder := ident (diffBinderType <|> diffBinderValue)?
syntax "‚àÇ" diffBinder "," term:66 : term
syntax "‚àÇ" "(" diffBinder ")" "," term:66 : term
macro_rules
| `(‚àÇ $x:ident, $f) =>
  `(‚àÇ Œª $x => $f)
| `(‚àÇ $x:ident : $type:term, $f) =>
  `(‚àÇ Œª $x : $type => $f)
| `(‚àÇ $x:ident := $val:term, $f) =>
  `((‚àÇ Œª $x => $f) $val)
| `(‚àÇ ($b:diffBinder), $f) =>
  `(‚àÇ $b, $f)


--------------------------------------------------------------------------------
-- Smooth Differential --
--------------------------------------------------------------------------------

instance differential.arg_x.isSmooth (f : X ‚Üí Y) [IsSmoothT f] 
  : IsSmoothNT 2 (Œª x dx => ‚àÇ f x dx) := sorry_proof
instance differential.arg_dx.isLin    (f : X ‚Üí Y) [IsSmoothT f] (x : X) 
  : IsLinT (Œª dx => ‚àÇ f x dx) := sorry_proof

instance differential.arg_y.isLin 
  (f : X ‚Üí Y ‚Üí Z) [IsSmoothT f] [‚àÄ x, IsLinT (f x)] (x dx) 
  : IsLinT (Œª y => ‚àÇ f x dx y) := sorry_proof
instance differential.arg_y.isSmooth (f : X ‚Üí Y ‚Üí Z) [IsSmoothNT 2 f] (x dx) 
  : IsSmoothT (Œª y => ‚àÇ f x dx y) := sorry_proof

instance differential.arg_x.comp.isSmooth {X Y Z} [Vec X] [Vec Y] [Vec Z] [Vec W]
  (f : Y ‚Üí Z ‚Üí W) [IsSmoothNT 2 f]
  (g : X ‚Üí Y) [IsSmoothT g]
  : IsSmoothT (Œª x => ‚àÇ (f (g x))) := sorry_proof

instance curry_is_smooth (f : X ‚Üí Y ‚Üí Z) [IsSmoothNT 2 f] 
  : IsSmoothT Œª x => Œª y ‚üø f x y := sorry_proof -- follows from currying 

instance : IsLin (Œª (f : X ‚üø Y) => (f : X ‚Üí Y)) := sorry_proof
instance : IsLin (Œª (f : X ‚ä∏ Y) => (f : X ‚Üí Y)) := sorry_proof

instance (f : X ‚Üí Y) [IsSmoothT f] 
  : IsSmoothT Œª x => Œª dx ‚ä∏ ‚àÇ f x dx:= sorry_proof 

noncomputable
def Smooth.differential (f : X ‚üø Y) : (X ‚üø X ‚ä∏ Y) := fun x ‚üø fun dx ‚ä∏ ‚àÇ f.1 x dx

instance (f : X ‚üø Y) : Partial f (Smooth.differential f) := ‚ü®‚ü©


--------------------------------------------------------------------------------
-- Scalar Differential --
--------------------------------------------------------------------------------

noncomputable
abbrev differentialScalar (f : ‚Ñù ‚Üí X) (t : ‚Ñù) : X := ‚àÇ f t 1

noncomputable
abbrev Smooth.differentialScalar (f : ‚Ñù ‚üø X) : ‚Ñù ‚üø X := Œª t ‚üø ‚àÇ f t 1

@[default_instance] 
instance (f : ‚Ñù ‚Üí X) : Differential f (differentialScalar f) := ‚ü®‚ü©

instance (f : ‚Ñù ‚üø X) : Differential f (Smooth.differentialScalar f) := ‚ü®‚ü©

 
-- Notation 
-- ‚ÖÜ s, f s         --> ‚ÖÜ Œª s => f s
-- ‚ÖÜ s : ‚Ñù, f s     --> ‚ÖÜ Œª s : ‚Ñù => f s
-- ‚ÖÜ s := t, f s    --> (‚ÖÜ Œª s => f s) t
syntax "‚ÖÜ" diffBinder "," term:66 : term
syntax "‚ÖÜ" "(" diffBinder ")" "," term:66 : term
macro_rules
| `(‚ÖÜ $x:ident, $f) =>
  `(‚ÖÜ Œª $x => $f)
| `(‚ÖÜ $x:ident : $type:term, $f) =>
  `(‚ÖÜ Œª $x : $type => $f)
| `(‚ÖÜ $x:ident := $val:term, $f) =>
  `((‚ÖÜ Œª $x => $f) $val)
| `(‚ÖÜ ($b:diffBinder), $f) =>
  `(‚ÖÜ $b, $f)


--------------------------------------------------------------------------------
-- Dual Number Differential --
--------------------------------------------------------------------------------

noncomputable
def tangentMap (f : X ‚Üí Y) : X√óX ‚Üí Y√óY := Œª (x,dx) => (f x, ‚àÇ f x dx)

instance : IsSmoothN 2 (Prod.mk : X ‚Üí Y ‚Üí X√óY) := sorry_proof

instance (f : X ‚Üí Y) : IsSmooth (Œª (x,dx) => ‚àÇ f x dx) := sorry_proof
instance (f : X ‚üø Y) : IsSmooth (Œª (x,dx) => ‚àÇ f x dx) := sorry_proof

noncomputable
def Smooth.tangentMap (f : X ‚üø Y) : X√óX ‚üø Y√óY := Œª xdx ‚üø (f xdx.1, ‚àÇ f xdx.1 xdx.2)

@[default_instance]
instance (f : X ‚Üí Y) : TangentMap f (tangentMap f) := ‚ü®‚ü©

instance (f : X ‚üø Y) : TangentMap f (Smooth.tangentMap f) := ‚ü®‚ü©


--------------------------------------------------------------------------------
-- Forward Differential --
--------------------------------------------------------------------------------
--
-- Usefull when you want to compute jacobian-vector-product for multiple different 
-- vectors but at the same point. For a single jacobian-vector-product use `tangentMap`
-- 

@[reducible]
class ForwardDifferential (Œ± : Type) (Œ≤ : outParam Type) where
  forwardDifferential : Œ± ‚Üí Œ≤

export ForwardDifferential (forwardDifferential)

prefix:max "‚Ñ±" => forwardDifferential

@[default_instance]
noncomputable
instance : ForwardDifferential (X ‚Üí Y) (X ‚Üí Y√ó(X‚ÜíY)) where
  forwardDifferential := Œª f x => (f x, Œª dx => ‚àÇ f x dx)

-- noncomputable
-- instance : ForwardDifferential (X ‚üø Y) (X ‚üø Y√ó(X‚ä∏Y)) where
--   forwardDifferential := Œª f => Œª x ‚üø (f x, Œª dx ‚ä∏ ‚àÇ f x dx)


--------------------------------------------------------------------------------
-- Differential Rules --
--------------------------------------------------------------------------------

@[simp ‚Üì, autodiff]
theorem differential.of_id
  : ‚àÇ (Œª x : X => x) = Œª x dx => dx := sorry_proof

@[simp ‚Üì, autodiff]
theorem differential.of_const (x : X)
  : ‚àÇ (Œª y : Y => x) = Œª y dy => (0 : X) := sorry_proof

@[simp ‚Üì low-3, autodiff low-3]
theorem differential.of_swap (f : Œ± ‚Üí X ‚Üí Y) [‚àÄ i, IsSmoothT (f i)]
  : ‚àÇ (Œª x a => f a x) = Œª x dx a => ‚àÇ (f a) x dx := sorry_proof

@[simp ‚Üì low-1, autodiff low-1]
theorem differential.of_comp
  (f : Y ‚Üí Z) [IsSmoothT f] 
  (g : X ‚Üí Y) [IsSmoothT g]
  : ‚àÇ (Œª x => f (g x)) 
    = 
    Œª x dx => 
      let (y,dy) := (ùíØ g) (x,dx)
      -- let y := g x
      -- let dy := ‚àÇ g x dx
      ‚àÇ f y dy 
  := sorry_proof

@[simp ‚Üì low-2, autodiff low-2]
theorem differential.of_diag
  (f : Y‚ÇÅ ‚Üí Y‚ÇÇ ‚Üí Z) [IsSmoothNT 2 f]
  (g‚ÇÅ : X ‚Üí Y‚ÇÅ) [IsSmoothT g‚ÇÅ]
  (g‚ÇÇ : X ‚Üí Y‚ÇÇ) [IsSmoothT g‚ÇÇ]
  : ‚àÇ (Œª x => f (g‚ÇÅ x) (g‚ÇÇ x)) 
    = 
    Œª x dx => 
      let (y‚ÇÅ,dy‚ÇÅ) := ùíØ g‚ÇÅ (x,dx)
      let (y‚ÇÇ,dy‚ÇÇ) := ùíØ g‚ÇÇ (x,dx)
      -- let y‚ÇÅ := g‚ÇÅ x
      -- let dy‚ÇÅ := ‚àÇ g‚ÇÅ x dx
      -- let y‚ÇÇ := g‚ÇÇ x
      -- let dy‚ÇÇ := ‚àÇ g‚ÇÇ x dx
      ‚àÇ f y‚ÇÅ dy‚ÇÅ y‚ÇÇ +  ‚àÇ (f y‚ÇÅ) y‚ÇÇ dy‚ÇÇ 
  := sorry_proof

@[simp ‚Üì low, autodiff low]
theorem differential.of_parm
  (f : X ‚Üí Œ± ‚Üí Y) [IsSmoothT f] (a : Œ±)
  : ‚àÇ (Œª x => f x a) = Œª x dx => ‚àÇ f x dx a := 
by
  rw[differential.of_swap (Œª a x => f x a)]

@[simp ‚Üì, autodiff]
theorem differential.of_eval
  (a : Œ±)
  : ‚àÇ (Œª f : Œ± ‚Üí Y => f a) = Œª _ df => df a := by simp

@[simp ‚Üì, autodiff]
theorem Prod.fst.arg_xy.diff_simp
  : ‚àÇ (Prod.fst : X√óY ‚Üí X)
    =
    Œª xy dxy => dxy.1
  := sorry_proof

@[simp ‚Üì, autodiff]
theorem Prod.snd.arg_xy.diff_simp
  : ‚àÇ (Prod.snd : X√óY ‚Üí Y)
    =
    Œª xy dxy => dxy.2
  := sorry_proof


--------------------------------------------------------------------------------
-- Tangent Map Rules --
--------------------------------------------------------------------------------

@[simp ‚Üì, autodiff]
theorem tangentMap.of_id
  : ùíØ (Œª x : X => x) = Œª xdx => xdx 
  := by simp[tangentMap]; done

@[simp ‚Üì, autodiff]
theorem tangentMap.of_const (x : X)
  : ùíØ (Œª y : Y => x) = Œª (y,dy) => (x,0) 
  := by simp[tangentMap]; done

@[simp ‚Üì low-3, autodiff]
theorem tangentMap.of_swap (f : Œ± ‚Üí X ‚Üí Y) [‚àÄ i, IsSmoothT (f i)]
  : ùíØ (Œª x a => f a x) = Œª (x,dx) => (Œª a => f a x, Œª a => ‚àÇ (f a) x dx) 
  := by simp[tangentMap]; done

@[simp ‚Üì low-1, autodiff]
theorem tangentMap.of_comp
  (f : Y ‚Üí Z) [IsSmoothT f] 
  (g : X ‚Üí Y) [IsSmoothT g] 
  : ùíØ (Œª x => f (g x)) 
    = 
    Œª xdx => ùíØ f (ùíØ g xdx)
  := by simp[tangentMap]; done

@[simp ‚Üì low-2, autodiff]
theorem tangentMap.of_diag
  (f : Y‚ÇÅ ‚Üí Y‚ÇÇ ‚Üí Z) [IsSmoothNT 2 f]
  (g‚ÇÅ : X ‚Üí Y‚ÇÅ) [IsSmoothT g‚ÇÅ]
  (g‚ÇÇ : X ‚Üí Y‚ÇÇ) [IsSmoothT g‚ÇÇ]
  : ùíØ (Œª x => f (g‚ÇÅ x) (g‚ÇÇ x))
    = 
    Œª (x,dx) => 
      let (y‚ÇÅ,dy‚ÇÅ) := ùíØ g‚ÇÅ (x,dx)
      let (y‚ÇÇ,dy‚ÇÇ) := ùíØ g‚ÇÇ (x,dx)
      -- (f y‚ÇÅ y‚ÇÇ, ‚àÇ f y‚ÇÅ dy‚ÇÅ y‚ÇÇ + ‚àÇ (f y‚ÇÅ) y‚ÇÇ dy‚ÇÇ)
      ùíØ (uncurryN 2 f) ((y‚ÇÅ,y‚ÇÇ),(dy‚ÇÅ,dy‚ÇÇ)) 
  := by simp [tangentMap, uncurryN, Prod.Uncurry.uncurry]; done

/-- Last resort theorem that changes tangent map to normal differential 

Bilinear maps should usually provide a rewrite rule for `ùíØ (uncurryN 2 f)`
-/
@[simp ‚Üì low-5]
theorem tangentMap.of_uncurryN (f : Y‚ÇÅ ‚Üí Y‚ÇÇ ‚Üí Z) [IsSmoothNT 2 f]
  : ùíØ (uncurryN 2 f) 
    =
    Œª ((y‚ÇÅ,y‚ÇÇ),(dy‚ÇÅ,dy‚ÇÇ)) =>
    (f y‚ÇÅ y‚ÇÇ, ‚àÇ f y‚ÇÅ dy‚ÇÅ y‚ÇÇ + ‚àÇ (f y‚ÇÅ) y‚ÇÇ dy‚ÇÇ)
  := by simp[tangentMap, uncurryN, Prod.Uncurry.uncurry]; done

@[simp ‚Üì low, autodiff]
theorem tangentMap.of_parm
  (f : X ‚Üí Œ± ‚Üí Y) [IsSmoothT f] (a : Œ±)
  : ùíØ (Œª x => f x a) = Œª xdx => let (f',df') := ùíØ f xdx; (f' a, df' a) 
  := by simp[tangentMap, uncurryN, Prod.Uncurry.uncurry]; done

@[simp ‚Üì, autodiff]
theorem tangentMap.of_eval
  (a : Œ±)
  : ‚àÇ (Œª f : Œ± ‚Üí Y => f a) = Œª _ df => df a := by simp


-- @[simp ‚Üì low, autodiff]
-- theorem uncurry.arg_xy.diff_simp
--   (f : X ‚Üí Y ‚Üí Z) [IsSmoothNT 2 f]
--   : ‚àÇ (Œª (xy : (X√óY)) => f xy.1 xy.2) = Œª (x,y) (dx,dy) => ‚àÇ f x dx y + ‚àÇ (f x) y dy := sorry_proof

--   -- : ‚àÇ (Œª ((x,y) : (X√óY)) => f x y) = Œª (x,y) (dx,dy) => ‚àÇ f x dx y + ‚àÇ (f x) y dy := sorry_proof 

-- @[simp ‚Üì low, autodiff]
-- theorem uncurry.arg_xy.parm1.diff_simp
--   (a : Œ±)
--   (f : X ‚Üí Y ‚Üí Œ± ‚Üí Z) [IsSmoothNT 2 f]
--   : ‚àÇ (Œª (xy : (X√óY)) => f xy.1 xy.2 a) = Œª (x,y) (dx,dy) => ‚àÇ f x dx y a + ‚àÇ (f x) y dy a := sorry_proof



--------------------------------------------------------------------------------

/-- Differential of linear function is the function itself.

This theorem is too general and we do not want to try to apply it 
every time we try to differentiate something. That is why it it has 
low priority and more importantly it asks for `IsLin` and not for `IsLinT`.
Only elementary functions(that are not composite composite) are allowed
to be differentiated with this theorem. -/
@[simp low, autodiff] 
theorem diff_of_linear (f : X ‚Üí Y) [IsLin f]
  : ‚àÇ f = Œª _ dx => f dx := sorry_proof

@[simp low, autodiff] 
theorem diff_of_linear_2_1 (f : X ‚Üí Y ‚Üí Z) [IsLinN 2 f] : ‚àÇ f = Œª _ dx _ => f dx 0 := sorry_proof
@[simp low, autodiff] 
theorem diff_of_linear_2_2 (f : X ‚Üí Y ‚Üí Z) [IsLinN 2 f] (x : X) : ‚àÇ (f x) = Œª _ dy => f 0 dy := sorry_proof


