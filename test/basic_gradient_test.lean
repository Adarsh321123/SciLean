-- import SciLean.Core.Functions
-- import SciLean.Tactic

import SciLean.Core.Functions

namespace SciLean

variable {Œ± Œ≤ Œ≥ : Type}
variable {X Y Z : Type} [Hilbert X] [Hilbert Y] [Hilbert Z]
variable {Œπ Œ∫ : Type} [Enumtype Œπ] [Enumtype Œ∫]

variable {n : Nat} [Nonempty (Fin n)]

example (y : X)
  : 
    ‚àá (Œª x : X => ‚ü™x,x‚ü´) = Œª x : X => (1:‚Ñù) * x + (1:‚Ñù) * x
  := by simp; unfold hold; simp done

-- @[simp low]
-- This can loop together with `sum_into_lambda`
theorem sum_of_linear {X Y Œπ} [Enumtype Œπ] [Vec X] [Vec Y]
  (f : X ‚Üí Y) [IsLin f]
  (g : Œπ ‚Üí X)
  : (‚àë i, f (g i)) = f (‚àë i, g i)
  := sorry

@[simp] 
theorem sum_into_lambda {X Y Œπ} [Enumtype Œπ] [Vec Y]
  (f : Œπ ‚Üí X ‚Üí Y)
  : (‚àë i, Œª j => f i j) = (Œª j => ‚àë i, f i j)
  := sorry

@[simp] theorem one_smul {X} [Vec X] (x : X) : (1:‚Ñù) * x = x := sorry

instance (f : X ‚Üí Y) [HasAdjDiff f] (x : X) : IsLin (Œ¥‚Ä† f x) := sorry

-- set_option trace.Meta.Tactic.simp.discharge true in
-- set_option trace.Meta.Tactic.simp.unify true in
@[simp]
theorem asdf [Nonempty Œπ]
  (f : Y ‚Üí Z) [HasAdjDiff f]
  (g : X ‚Üí Œπ ‚Üí Y) [HasAdjDiff g]
  : 
    Œ¥‚Ä† (Œª x i => f (g x i)) = Œª x dx' => (Œ¥‚Ä† g x) Œª i => ((Œ¥‚Ä† f) (g x i) (dx' i))
:= by 
  funext x dx';
  simp; simp only [sum_of_linear]; simp
  done


@[simp high] -- try to avoid using this theorem
theorem hohoho [SemiHilbert Y‚ÇÇ] [SemiHilbert Y‚ÇÅ] [Nonempty Œπ]
  (f : Y‚ÇÅ ‚Üí Y‚ÇÇ ‚Üí Z) [IsSmooth f]
  [‚àÄ y‚ÇÇ, HasAdjDiff Œª y‚ÇÅ => f y‚ÇÅ y‚ÇÇ]
  [‚àÄ y‚ÇÅ, HasAdjDiff Œª y‚ÇÇ => f y‚ÇÅ y‚ÇÇ]
  (g‚ÇÅ : X ‚Üí Œπ ‚Üí Y‚ÇÅ) [HasAdjDiff g‚ÇÅ]
  (g‚ÇÇ : X ‚Üí Œπ ‚Üí Y‚ÇÇ) [HasAdjDiff g‚ÇÇ]
  : Œ¥‚Ä† (Œª x i => f (g‚ÇÅ x i) (g‚ÇÇ x i))
    = 
    Œª x dx' => 
      (Œ¥‚Ä† g‚ÇÅ x) (Œª i => (Œ¥‚Ä† (hold Œª y‚ÇÅ => f y‚ÇÅ (g‚ÇÇ x i))) (g‚ÇÅ x i) (dx' i))
      +
      (Œ¥‚Ä† g‚ÇÇ x) (Œª i => (Œ¥‚Ä† (hold Œª y‚ÇÇ => f (g‚ÇÅ x i) y‚ÇÇ)) (g‚ÇÇ x i) (dx' i))
:= by admit

  -- (apply diag.arg_x.adjDiff_simp (Œª y‚ÇÅ y‚ÇÇ => f y‚ÇÅ y‚ÇÇ a) g‚ÇÅ g‚ÇÇ)
  -- done

@[simp high + 1] -- try to avoid using this theorem
theorem hohohoo
  (g‚ÇÅ : X ‚Üí Œπ ‚Üí ‚Ñù) [HasAdjDiff g‚ÇÅ]
  (g‚ÇÇ : X ‚Üí Œπ ‚Üí Y) [HasAdjDiff g‚ÇÇ]
  : Œ¥‚Ä† (Œª x i => (g‚ÇÅ x i) * (g‚ÇÇ x i))
    = 
    Œª x dx' => 
      (Œ¥‚Ä† g‚ÇÅ x) (Œª i => ‚ü™dx' i, g‚ÇÇ x i‚ü´)
      +
      (Œ¥‚Ä† g‚ÇÇ x) (Œª i => g‚ÇÅ x i * dx' i)
:= by admit



set_option trace.Meta.Tactic.simp.rewrite true in
example (g : Œπ ‚Üí ‚Ñù) [Nonempty Œπ]
  : 
    ‚àá (Œª (f : Œπ ‚Üí ‚Ñù) => ‚àë i, (f i) * (f i)) g 
    = 
    (Œª _ => (1 : ‚Ñù)) 
  := by simp; unfold hold; simp done


example 
  : Œ¥ (fun (x : Fin n ‚Üí ‚Ñù) i => x (i + 1) * x i) 
    = 
    (fun x dx a => dx (a + 1) * x a + x (a + 1) * dx a) := 
by
  simp

-- set_option synthInstance.maxHeartbeats 2000 
-- set_option maxHeartbeats 50000 


-- set_option trace.Meta.Tactic.simp.discharge true in
-- set_option trace.Meta.Tactic.simp.rewrite true in
example : adjDiff (fun (x : Fin n ‚Üí ‚Ñù) => x i) = (fun x dx' j => kron i j * dx') :=
by
  simp
  done


-- @[simp] 
theorem sum_of_add {X Œπ} [Enumtype Œπ] [Vec X]
  (f g : Œπ ‚Üí X)
  : (‚àë i, f i + g i) = (‚àë i, f i) + (‚àë i, g i)
  := sorry

theorem sum_into_lambda {X Y Œπ} [Enumtype Œπ] [Vec Y]
  (f : Œπ ‚Üí X ‚Üí Y)
  : (‚àë i, Œª j => f i j) = (Œª j => ‚àë i, f i j)
  := sorry



-- set_option synthInstance.maxHeartbeats 2000 in
-- set_option maxHeartbeats 50000 in
-- set_option trace.Meta.Tactic.simp.discharge true in
-- set_option trace.Meta.Tactic.simp.rewrite true in
-- set_option trace.Meta.Tactic.simp.unify true in
example 
  : ‚àá (Œª (f : Fin n ‚Üí ‚Ñù) => ‚àë i, (f (i + 1))*(f i))
    = 
    (Œª (f : Fin n ‚Üí ‚Ñù) => (Œª i => ‚ü™1, f (i - 1)‚ü´) + (Œª i => f (i + 1))) 
  := 
by
  simp; simp only [sum_of_add, sum_into_lambda]; simp done
 
/-

-- set_option synthInstance.maxHeartbeats 2000 in
-- set_option maxHeartbeats 50000 in
example 
  : ‚àá (Œª (f : ‚Ñù^n) => ‚àë i, f[i + 1]*f[i])
    = 
    Œª (f : ‚Ñù^n) => PowType.intro Œª i => f[i - 1] + f[i + 1]
  := 
by 
  simp[gradient, adjoint_differential]
  simp[AtomicAdjointFun.adj,hold]
  done

-/ 


-- set_option trace.Meta.Tactic.simp.discharge true in
example {X} [Hilbert X] (x : X) 
  : 
    ‚àá (Œª x : X => ‚à•x‚à•¬≤) x = (2 : ‚Ñù) * x 
  := 
by simp done 


set_option synthInstance.maxHeartbeats 1000 in
set_option synthInstance.maxSize 2000 in


example (g : Fin n ‚Üí ‚Ñù)
  : 
    ‚àá (Œª (f : Fin n ‚Üí ‚Ñù) => ‚àë i, ‚ü™(f (i + 1) - f i), (f (i + 1) - f i)‚ü´) g 
    = 
    (Œª i => (2 : ‚Ñù) * (g (i - 1 + 1) - g (i - 1) - (g (i + 1) - g i))) 
  := 
by
  funext i; simp; unfold hold; simp;
  
  rw[!?(i - 1 + 1 = i)]
  done

/-

-- set_option synthInstance.maxHeartbeats 50000 in
-- set_option synthInstance.maxSize 2048 in                           
-- example (c : Fin n ‚Üí ‚Ñù) (k : ‚Ñù) : IsSmooth fun (x : Fin n ‚Üí Fin 3 ‚Üí ‚Ñù) (i : Fin n) => ‚à• ‚à•x i - x (i - 1)‚à•¬≤ - (c i) ‚à•¬≤ := by infer_instance

-- Too slow with `x : (‚Ñù^(3:‚Ñï))^n
-- Quite compicated
-- set_option trace.Meta.Tactic.simp.discharge true in
-- set_option synthInstance.maxHeartbeats 50000 in
-- set_option synthInstance.maxSize 2048 in                           
-- example (l : Fin n ‚Üí ‚Ñù)
--   : ‚àá (Œª (x : Fin n ‚Üí Fin 3 ‚Üí ‚Ñù) => ‚àë i, ‚à• ‚à•x i  - x (i-1)‚à•¬≤ - (l i)^2‚à•¬≤)
--     =
--     (fun (x : Fin n ‚Üí Fin 3 ‚Üí ‚Ñù) =>
--       (2:‚Ñù) * fun j =>
--         (‚à•x j - x (j - 1)‚à•¬≤ - l j ^ 2) * ((2:‚Ñù) * (x j - x (j - 1))) -
--         (‚à•x (j + 1) - x (j + 1 - 1)‚à•¬≤ - l (j + 1) ^ 2) * ((2:‚Ñù) * (x (j + 1) - x (j + 1 - 1))))
--   := 
-- by
  -- conv => 
  --   lhs
  --   simp[gradient]
  -- conv => 
  --   lhs
  --   simp
  -- done

-- set_option trace.Meta.Tactic.simp.rewrite true in
-- set_option synthInstance.maxSize 256 in
-- example
--   : ‚àá (Œª x : Fin n ‚Üí Fin 3 ‚Üí ‚Ñù => ‚àë i j, ‚à•x i - x j‚à•¬≤)
--     = 
--     0
--    -- (fun x => (2:‚Ñù) * ((fun j => (n:‚Ñù) * x j - fun j => sum fun i => x i j) - fun j => (fun j => sum fun i => x i j) - (n:‚Ñù) * x j))
--  := by
--    autograd    -- I was unable to typecheck the rhs, so we are just checking if `autograd` terminates on this
--    admit

-- set_option trace.Meta.Tactic.simp true in
-- example
--   : ùìë (Œª x : Fin n ‚Üí Fin 3 ‚Üí ‚Ñù => ‚àë i j, ‚à•x i - x j‚à•¬≤)
--     = 
--     0
--  := by
--    simp    -- I was unable to typecheck the rhs, so we are just checking if `autograd` terminates on this
--    admit


-- set_option synthInstance.maxHeartbeats 1000
-- example (g : Œπ ‚Üí ‚Ñù) 
--   : 
--     ‚àá (Œª (f : Œπ ‚Üí ‚Ñù) => ‚àë i, (42 : ‚Ñù) * f i) g 
--     = 
--     (Œª _ => (42 : ‚Ñù)) 
--   := by autograd done

-- example (g : Œπ ‚Üí ‚Ñù) 
--   : 
--     ‚àá (Œª (f : Œπ ‚Üí ‚Ñù) => ‚àë i, (f i)*(f i)) g = (2 : ‚Ñù) * g 
--   := 
-- by autograd; done


-- example : Œ¥ (Œª x : ‚Ñù^n => ‚àë i, x[i]) = Œª x dx => ‚àë i, dx[i] := by simp done
-- example : Œ¥ (Œª x : ‚Ñù^n => ‚àë i, 2*x[i]) = Œª x dx => ‚àë i, (2:‚Ñù)*dx[i] := by simp done
-- example : Œ¥ (Œª x : ‚Ñù^n => (‚àë i, x[i]*x[i])) = Œª x dx => (‚àë i, dx[i]*x[i]) + (‚àë i, x[i]*dx[i]) := by simp done
-- example : ‚àá (Œª x : ‚Ñù^n => ‚àë i, x[i]) = Œª x => PowType.intro (Œª i => (1:‚Ñù)) := by autograd done
-- example : ‚àá (Œª x : ‚Ñù^n => ‚àë i, x[i]*x[i]) = Œª x : ‚Ñù^n => (2:‚Ñù)*x := by autograd admit -- not quite there,
-- not sure what to do about this case

  --   example : ‚àá (Œª x => ‚àë i, x[i]*x[i-a]) x = ((lmk Œª i => x[i-a]) + (lmk Œª i => x[i+a])) := by autograd done
  --   -- example : ‚àá (Œª x => ‚àë i, (x[i+a] - x[i])*(x[i+a] - x[i])) x = 0 := by autograd done -- Needs some more sophisticated simplifications

    -- variable {n : Nat} [NonZero n] (a : Fin n)

    -- example : ‚àá (Œª (f : Fin n ‚Üí ‚Ñù) => ‚àë i, (f (i+a) - f i)*(f (i+a) - f i)) 
    --           = 
    --           (Œª (f : Fin n ‚Üí ‚Ñù) i => 2 * (f (i - a + a) - f (i - a) - (f (i + a) - f i))) := by autograd done
  --   example (c : ‚Ñù) : ‚àá (Œª (f : Fin n ‚Üí ‚Ñù) => ‚àë i, c*(f i)*(f i)) = (Œª (f : Fin n ‚Üí ‚Ñù) => (2:‚Ñù)*c*f) := by autograd done

-/
